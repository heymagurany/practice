@{
    ViewBag.Title = "Arc";
    Layout = "~/Views/Shared/_Layout.cshtml";
}
<div id="map-canvas" />
@section scripts
{
    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?key=AIzaSyC4IrIT_byOV1Ov6SwGoTjnKnXtRfKwMRo&libraries=drawing&sensor=false"></script>
    <script type="text/javascript" src="~/Scripts/v3_epoly.js"></script>
    <script type="text/javascript">
        /* Based the on the Latitude/longitude spherical geodesy formulae & scripts
          at http://www.movable-type.co.uk/scripts/latlong.html
          (c) Chris Veness 2002-2010
       */
        google.maps.LatLng.prototype.DestinationPoint = function (brng, dist) {
            var radius = 6378137.0; // earth's mean radius in meters
            var brngRads = brng.toRad();
            var lat1 = this.lat().toRad(), lon1 = this.lng().toRad();
            var lat2 = Math.asin(Math.sin(lat1) * Math.cos(dist / radius) + Math.cos(lat1) * Math.sin(dist / radius) * Math.cos(brngRads));
            var lon2 = lon1 + Math.atan2(Math.sin(brngRads) * Math.sin(dist / radius) * Math.cos(lat1), Math.cos(dist / radius) - Math.sin(lat1) * Math.sin(lat2));

            return new google.maps.LatLng(lat2.toDeg(), lon2.toDeg());
        }

        // === A function which returns the bearing between two LatLng in radians ===
        // === If v1 is null, it returns the bearing between the first and last vertex ===
        // === If v1 is present but v2 is null, returns the bearing from v1 to the next vertex ===
        // === If either vertex is out of range, returns void ===
        google.maps.LatLng.prototype.Bearing = function (otherLatLng) {
            var from = this;
            var to = otherLatLng;
            if (from.equals(to)) {
                return 0;
            }
            var lat1 = from.latRadians();
            var lon1 = from.lngRadians();
            var lat2 = to.latRadians();
            var lon2 = to.lngRadians();
            var angle = -Math.atan2(Math.sin(lon1 - lon2) * Math.cos(lat2), Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));
            if (angle < 0.0) {
                angle += Math.PI * 2.0;
            }
            if (angle > Math.PI) {
                angle -= Math.PI * 2.0;
            }
            return parseFloat(angle.toDeg());
        }

        /**
         * Extend the Number object to convert degrees to radians
         */
        Number.prototype.toRad = function () {
            return this * Math.PI / 180;
        };

        /**
         * Extend the Number object to convert radians to degrees
         */
        Number.prototype.toDeg = function () {
            return this * 180 / Math.PI;
        };

        /**
         * Normalize a heading in degrees to between 0 and +360
         */
        Number.prototype.toBrng = function () {
            return (this.toDeg() + 360) % 360;
        };

        (function () {
            var infowindow = new google.maps.InfoWindow(
            {
                size: new google.maps.Size(150, 50)
            });

            function createMarker(map, latlng, html) {
                var contentString = html;
                var marker = new google.maps.Marker({
                    position: latlng,
                    map: map,
                    zIndex: Math.round(latlng.lat() * -100000) << 5
                });
                //bounds.extend(latlng);
                google.maps.event.addListener(marker, 'click', function () {
                    infowindow.setContent(contentString);
                    infowindow.open(map, marker);
                });
            }

            function drawArc(center, initialBearing, finalBearing, radius, direction) {
                var points = 32;
                var extp = new Array();

                if (initialBearing > finalBearing) {
                    if(direction > 0) {
                        finalBearing += 360;
                    }
                } else {
                    if(direction < 0) {
                        finalBearing -= 360;
                    }
                }

                var deltaBearing = (finalBearing - initialBearing) / points;
                var maxBearing = 5;

                while ((deltaBearing < -maxBearing) || (deltaBearing > maxBearing)) {
                    points *= 2;
                    deltaBearing = (finalBearing - initialBearing) / points;
                }

                for (var i = 0; (i < points + 1) ; i++) {
                    var point = center.DestinationPoint(initialBearing + i * deltaBearing, radius);

                    extp.push(point);
                    //bounds.extend(point);
                }

                return extp;
            }

            //var bounds = null;

            function initialize() {
                var myOptions = {
                    zoom: 17,
                    center: new google.maps.LatLng(40.470735, -86.928919),
                    mapTypeControl: true,
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.DROPDOWN_MENU
                    },
                    navigationControl: true,
                    mapTypeId: google.maps.MapTypeId.ROADMAP
                }
                var map = new google.maps.Map(document.getElementById("map-canvas"), myOptions);

                //bounds = new google.maps.LatLngBounds();

                google.maps.event.addListener(map, 'click', function () {
                    infowindow.close();
                });

                var startPoint = new google.maps.LatLng(40.468355, -86.929117);
                var endPoint = new google.maps.LatLng(40.469249, -86.930464);
                var centerPoint = new google.maps.LatLng(40.470735, -86.928919);

                createMarker(map, startPoint, "start: " + startPoint.toUrlValue(6) + "<br>distance to center: " + (centerPoint.distanceFrom(startPoint) / 1000).toFixed(3) + " km<br>Bearing: " + centerPoint.Bearing(startPoint) + "<br><a href='javascript:map.setCenter(new google.maps.LatLng(" + startPoint.toUrlValue(6) + "));map.setZoom(20);'>zoom in</a> - <a href='javascript:map.fitBounds(bounds);'>zoom out</a>");
                createMarker(map, endPoint, "end: " + endPoint.toUrlValue(6) + "<br>distance to center: " + (centerPoint.distanceFrom(endPoint) / 1000).toFixed(3) + " km<br>Bearing: " + centerPoint.Bearing(endPoint) + "<br><a href='javascript:map.setCenter(new google.maps.LatLng(" + endPoint.toUrlValue(6) + "));map.setZoom(20);'>zoom in</a> - <a href='javascript:map.fitBounds(bounds);'>zoom out</a>");
                createMarker(map, centerPoint, "center: " + centerPoint.toUrlValue(6));

                var arcPts = drawArc(centerPoint, centerPoint.Bearing(startPoint), centerPoint.Bearing(endPoint), centerPoint.distanceFrom(startPoint), -1);
                // add the start and end lines
                arcPts.push(centerPoint);
                //bounds.extend(centerPoint);
                arcPts.push(startPoint);

                var piePoly = new google.maps.Polygon({
                    paths: [arcPts],
                    strokeColor: "#00FF00",
                    strokeOpacity: 0.5,
                    strokeWeight: 2,
                    fillColor: "#FF0000",
                    fillOpacity: 0.35,
                    map: map
                });

                //map.fitBounds(bounds);
            }

            google.maps.event.addDomListener(window, "load", initialize);
        })(jQuery);
    </script>
}